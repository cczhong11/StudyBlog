<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>array on Learn More</title>
    <link>http://study.tczhong.com/tags/array/</link>
    <description>Recent content in array on Learn More</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 24 Aug 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://study.tczhong.com/tags/array/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Array算法题的思考</title>
      <link>http://study.tczhong.com/post/algo/array/</link>
      <pubDate>Fri, 24 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://study.tczhong.com/post/algo/array/</guid>
      <description>Array 算法题的思考 数组类的算法是在我做的题目中是最多的，相对来说也是最好理解的它也可以包罗万象，使用各种各样的算法。用数组可以实现很多基本的数据结构。比如heap。所以这部分需要好好掌握。
SWAP 需要应用到数组元素交换是一类非常常见的题目，比如说求最大的K个数，这种题目一般都是使用基本的快速排序思想。也就是说，我们把这个数组分成两部分，一部分是比当前这个数字大的，另外一部分是比这个当前数字小的，这样我们可以快速的把一个array分成两部分，然后再分别对这两部分进行处理。
如果只是需要移动一些数字，比如说移动零或者整个数组只有三个数，那么可以用一些更简单思想，比如说记录下所有非0的数，或者记录下这些数字的个数，然后把前面全换成这些非0数，后面换成零。这样做的好处就是不需要交换。或者一个记录非0的地方，另外一个记录当前位置，如果这个不是零，那么就遇上一个非0的东西交换。所以总体思路都是双指针的思想，一个记录当前遍历的位置，另外一个记录上一次符合条件的位置。
 27. Remove Element 75. Sort Colors 283. Move Zeroes 215. Kth Largest Element in an Array  subarray 这又是一大类数组常遇到的题目，比如说求子数组的和，或者判断这个子数组是否符合某些规律等等。与字符串处理substring有异曲同工之妙，一般也都是双指针，如果发现和大于某个值的时候，那么就把起始值增大。
另外一种常见的思路就是记录从零开始到现在的子序列的和。然后，用当前的和减去目标值，然后看这个值是否在我们存好的hashmap里，如果在的话就说明存在这么个序列，我们就可以返回这个值。这类题目需要先判断有没有，再加入map，避免0的问题。当限制subarray长度时也可以用两个数字代表，不使用hashtable。
对于求max average的题目，可以使用binary search找这个最大的average，思路不是很直接。就是直接找这个值，然后看存不存在符合的subarray.
其中一个有趣的地方是可以用加法代替乘法，换成log。
 53. Maximum Subarray 325. Maximum Size Subarray Sum Equals k 209. Minimum Size Subarray Sum 560. Subarray Sum Equals K 643. Maximum Average Subarray I 644. Maximum Average Subarray II 713. Subarray Product Less Than K  对于subarray个数的题目可以一般有这个思路：</description>
    </item>
    
  </channel>
</rss>