<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on Learn More</title>
    <link>http://study.tczhong.com/tags/leetcode/</link>
    <description>Recent content in Leetcode on Learn More</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 21 Sep 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://study.tczhong.com/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Bit算法题的思考</title>
      <link>http://study.tczhong.com/post/algo/bit/</link>
      <pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://study.tczhong.com/post/algo/bit/</guid>
      <description>bit操作题目思考 说实话这类题目比较考验智商，如果之前没有见过的话做出来的难度比较大。基本思路很多都是利用XOR解题
find bit parity 这题就是找奇偶校验位的值，有奇数个1就是1，有偶数个1就是0。在513 datalab出现过，现在在思考感觉没那么难了。基本思路就是把所有的1进行XOR，看最后是1还是0.
x ^= x &amp;gt;&amp;gt; 16 x ^= x &amp;gt;&amp;gt; 8 x ^= x &amp;gt;&amp;gt; 4 x ^= x &amp;gt;&amp;gt; 2 x ^= x &amp;gt;&amp;gt; 1 x &amp;amp;= 1;  找出2个只出现一次的数值 这个题目可以全部XOR，得到x XOR y。之后取其中一位，然后把数组分成2部分，一半有这位，一半没有，然后用前两题的思路。</description>
    </item>
    
    <item>
      <title>Linkedlist算法题的思考</title>
      <link>http://study.tczhong.com/post/algo/linkedlist/</link>
      <pubDate>Mon, 10 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://study.tczhong.com/post/algo/linkedlist/</guid>
      <description>链表题目的思考 链表是一个比较常见的数据结构，但是leetcode里的题目相对来说不多，题目也不是很难。最重要的思想就是递归的思路。对于每一个节点，都可以看作一个链表的起点。
merge 这类题目就是用一个递归函数，参数是两个头指针，得到新的指针之后，其中一个向后，然后再递归调用就可以。sort list就是一个merge sort的思想
 2. Add Two Numbers 21. Merge Two Sorted Lists 23. Merge k Sorted Lists 148. Sort List  cycle, two pointers 判断有没有环的题目可以使用快慢指针，当两个指针重新相遇的时候可以判断出现环。
删掉倒数节点可以使用两个指针，一个先走k个，之后两个一起走，快的那个到结尾的时候就说明慢指针指向那个节点是需要删除的。
找交点的题目也是两个节点，其实和找环的思路一样，不过是两个指针走到底了从另一边重新开始，基本思路就是两边走的路程一致。
 141. Linked List Cycle 142. Linked List Cycle II 19. Remove Nth Node From End of List 876. Middle of the Linked List 160. Intersection of Two Linked Lists  reverse Reverse 的思想也比较简单，就是记得保存当前的下一个节点。反转链表的思路就是每次把最后一个节点放到表头。分组reverse的话就是链表的思路叠加，先找出前k个，后面的点就是同样的子问题，做完reverse之后就可以接上后面的点。
如果只是print，可以用stack的递归思想，可以做到不使用任何空间。看palindrome可以把一半reverse来比较。
 24. Swap Nodes in Pairs 25.</description>
    </item>
    
    <item>
      <title>DP算法题的思考</title>
      <link>http://study.tczhong.com/post/algo/interval/</link>
      <pubDate>Sat, 08 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://study.tczhong.com/post/algo/interval/</guid>
      <description> INTERVAL 算法题目的思考 这类题目还是比较常见的。就是给你一些区间，需要你判断重叠之类的。相对来说不难，一些常见的方法是用按start的大小排序，之后end1&amp;lt;start2 就代表有重叠。
 56. Merge Intervals 57. Insert Interval 436. Find Right Interval 729. My Calendar I 731. My Calendar II 732. My Calendar III 253. Meeting Rooms II  </description>
    </item>
    
    <item>
      <title>DP算法题的思考</title>
      <link>http://study.tczhong.com/post/algo/dp/</link>
      <pubDate>Tue, 04 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://study.tczhong.com/post/algo/dp/</guid>
      <description>DP 算法题目的思考 dp全称是动态规划，是一类被人又喜欢又讨厌的题目。喜欢是因为找到递推关系之后题目就变得简单了，讨厌的原因是这类题目常常很难想到递推关系。
dp的核心思想就是把一个复杂的问题分解成简单的子问题，并且可以利用递推的方式来解决。所有dp题目的核心是：
 递推公式 deduction formula 初始化 initialization 空间优化 space improvement  路径数量 这类题目就是看有几种方式可以到这个点，然后把这几种方式的路径加起来就可以。这是自下而上的思想，对于青蛙跳的那道题也可以自上而下利用递归的思路解题。只要可以跳到，就可以变成一个子问题，把这个点当做起点来进行。
word break 这类题目就可以使用相同的思想。思路是判断前i个是否可以组成，之后就判断这从i到j是否是一个单词。如果要记录下来所有的组成可能的话就可以使用dfs了。
 62. Unique Paths 63. Unique Paths II 64. Minimum Path Sum 70. Climbing Stairs 91. Decode Ways 139. Word Break 198. House Robber 213. House Robber II 338. Counting Bits 357. Count Numbers with Unique Digits 403. Frog Jump 518. Coin Change 2 746. Min Cost Climbing Stairs 413. Arithmetic Slices 446.</description>
    </item>
    
    <item>
      <title>Stack算法题的思考</title>
      <link>http://study.tczhong.com/post/algo/stack/</link>
      <pubDate>Tue, 04 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://study.tczhong.com/post/algo/stack/</guid>
      <description>Stack 算法题的思考 这类题目也是比较多的，一般比较繁琐。思路类似DFS，不过可以不使用递归实现。
String 解析类 这类比较多的就是计算器，以及分析括号里的内容。例如解析 3[a]2[bc],这时候就可以在遇到[的时候把之前的东西都压到栈里，之后当遇到]的时候把内容再pop出来。
对于计算器，如果是后缀表达式的话，可以把结果都压到栈里，遇到运算符再pop出运算。有括号的话还是按括号的方法，主要要注意加法和乘法的区别。
计算器系列最重要的思想就是前一个符号看作大小的指示，之后那个才用来做计算。例如(1+2)+(3+4), +可以看作是是后一个括号的符号。对于1*2 + 6&amp;frasl;3,原理相同。在进行+6/3的时候，先把sign变成+6，并进行除法标记。之后再用除法。
 150. Evaluate Reverse Polish Notation 385. Mini Parser 394. Decode String 726. Number of Atoms 224. Basic Calculator 227. Basic Calculator II 770. Basic Calculator IV 772. Basic Calculator III  大小差距 还有一类题目就是问下一个比自己大的数还有多远，可以使用栈。栈里面存的都是比栈顶小的数，遇到比栈顶大的数n就可以弹出栈里的数j，因为这时我们可以知道比之前那个数j大的数在n了，更新之前那个数j的结果。
栈的作用存一个至今遇到的大值。栈底是最大的值，栈顶是至今遇到的大值里最小的。
for (int i = 0; i &amp;lt; n; i++) { while (!stack.isEmpty() &amp;amp;&amp;amp; temperatures[i] &amp;gt; temperatures[stack.peek()]) { int idx = stack.pop(); res[idx] = i - idx; } stack.</description>
    </item>
    
    <item>
      <title>Graph算法题的思考</title>
      <link>http://study.tczhong.com/post/algo/graph/</link>
      <pubDate>Tue, 28 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://study.tczhong.com/post/algo/graph/</guid>
      <description>graph 算法题目思考 Graph算是非常常见的题目，一般会给你一个2d array或一个数组代表联系，你可以使用这个输入来转换成一个图表示的数据结构，之后在图里做搜索。常见的算法：
 BFS，DFS union find A* Floyd and dijkstra  Leetcode里的题目的话主要都是dfs, bfs就可以解决，有些需要思考几个之间的关系的题目可以使用union find来做。少部分计算路径的题目需要使用一些基本的最短路径算法。
BFS and DFS BFS就是使用一个queue,每次在遍历一个点的时候就把这个点放到queue里，是一个FIFO的结构。一层一层的遍历，基本应用是在tree level 遍历。这种方法找最短路径比较好，问题是一次要走很多。相对来说，BFS和DFS都可以解决一道题目，区别只是遍历的顺序不同。 DFS需要使用stack来解决，或者递归。
 127. Word Ladder 130. Surrounded Regions 133. Clone Graph  对于找所有东西是不是一类的题目，经典题目就是看有几个岛的题目，利用dfs可以很方便的写出来。如果是无向图的话，从区域里的任意一点应该是可以到这个区域里任意一点的。所以只要有这个就可以找到所有是一类的点。
 200. Number of Islands 286. Walls and Gates  Dfs也可以用来实现有向图找环的策略，基本思路就是把图中的点标为白色（unvisited）,灰色(visiting)，黑色(visited)。如果在访问途中遇到灰色的节点，就说明这个点被访问过了，图中有环。
Union find 这类题目一般都是存在多个点属于一个类别的题目，之后可以通过图的关系把这些点合并到一个类别里面。union find 可以用来找无向图中是否有环。基本算法如下：
class DSU { int[] parent; public DSU(int N) { parent = new int[N]; for (int i = 0; i &amp;lt; N; ++i) parent[i] = i; } public int find(int x) { if (parent[x] !</description>
    </item>
    
    <item>
      <title>Array算法题的思考</title>
      <link>http://study.tczhong.com/post/algo/array/</link>
      <pubDate>Fri, 24 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://study.tczhong.com/post/algo/array/</guid>
      <description>Array 算法题的思考 数组类的算法是在我做的题目中是最多的，相对来说也是最好理解的它也可以包罗万象，使用各种各样的算法。用数组可以实现很多基本的数据结构。比如heap。所以这部分需要好好掌握。
SWAP 需要应用到数组元素交换是一类非常常见的题目，比如说求最大的K个数，这种题目一般都是使用基本的快速排序思想。也就是说，我们把这个数组分成两部分，一部分是比当前这个数字大的，另外一部分是比这个当前数字小的，这样我们可以快速的把一个array分成两部分，然后再分别对这两部分进行处理。
如果只是需要移动一些数字，比如说移动零或者整个数组只有三个数，那么可以用一些更简单思想，比如说记录下所有非0的数，或者记录下这些数字的个数，然后把前面全换成这些非0数，后面换成零。这样做的好处就是不需要交换。或者一个记录非0的地方，另外一个记录当前位置，如果这个不是零，那么就遇上一个非0的东西交换。所以总体思路都是双指针的思想，一个记录当前遍历的位置，另外一个记录上一次符合条件的位置。
 27. Remove Element 75. Sort Colors 283. Move Zeroes 215. Kth Largest Element in an Array  subarray 这又是一大类数组常遇到的题目，比如说求子数组的和，或者判断这个子数组是否符合某些规律等等。与字符串处理substring有异曲同工之妙，一般也都是双指针，如果发现和大于某个值的时候，那么就把起始值增大。
另外一种常见的思路就是记录从零开始到现在的子序列的和。然后，用当前的和减去目标值，然后看这个值是否在我们存好的hashmap里，如果在的话就说明存在这么个序列，我们就可以返回这个值。这类题目需要先判断有没有，再加入map，避免0的问题。当限制subarray长度时也可以用两个数字代表，不使用hashtable。
对于求max average的题目，可以使用binary search找这个最大的average，思路不是很直接。就是直接找这个值，然后看存不存在符合的subarray.
其中一个有趣的地方是可以用加法代替乘法，换成log。
 53. Maximum Subarray 325. Maximum Size Subarray Sum Equals k 209. Minimum Size Subarray Sum 560. Subarray Sum Equals K 643. Maximum Average Subarray I 644. Maximum Average Subarray II 713. Subarray Product Less Than K  对于subarray个数的题目可以一般有这个思路： - 1，2 中subarray个数为[1],[2],[1,2] - 1,2,3 中subarray个数为[1],[2],[1,2],[1,3],[2,3],[1,2,3]</description>
    </item>
    
    <item>
      <title>String算法题的思考</title>
      <link>http://study.tczhong.com/post/algo/string/</link>
      <pubDate>Wed, 22 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://study.tczhong.com/post/algo/string/</guid>
      <description>String 算法思考 String 类型的题目算是leetcode里第二多的题型，其实这个和array的使用方法差不太多，只不过其中有一些特定的使用场景。我在这里会将string分为几类问题，可能不能包括所有的类别，尽量使用较为统一的思路解释遇到的题目。
数据类型 首先要说清楚一点，在java中String是immutable的，也就是当你创建一个string后是不能修改的，如果你需要给他加内容，java会重新创一个新的实例。这样的问题就是如果使用s+=a,这样时间复杂度是O(n),在java中会重新复制一遍string再给你创建。
解决办法就是使用StringBuilder，这个的时间复杂度对于增加就是O(1).其中内部实现就是一个char[]
 sb.append(String str) sb.toString()  组合问题 这类问题就是需要得到某个字符串中包含的所有子集,或者是permutation.这类题日非常相似，需要找出符合条件的所有组合。基本思路是样的，可以使用DFS与backtrack实现。例如 Combination Sum,可以把这题变成一个子问题选择了数字n后，求解sum-n的子问题的解答。所以可以先排序选择第一个元素，然后在函数中记录以下这些：
 结果列表 当前路径存入的值， 所有可能的值 剩余的Sum 当前选择的位置,深度  在执行递归前将数字存入，在执行后从数组中删去。如果是计算permutation, 在参种增加一个数组用来判断当前数字是否访过。类似的题目有以下这些：
 17. Letter Combinations of a Phone Number 282. Expression Add Operators 39. Combination Sum 40. Combination Sum II 78. Subsets 79. Word Search 46. Permutations 47. Permutations II 266. Palindrome Permutation 267. Palindrome Permutation II 494. Target Sum 679. 24 Game 491. Increasing Subsequences  对于subset的题目，可以用以下的思路.</description>
    </item>
    
    <item>
      <title>树形算法题的思考</title>
      <link>http://study.tczhong.com/post/algo/tree/</link>
      <pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://study.tczhong.com/post/algo/tree/</guid>
      <description>树形算法题的思考 树形是一大题型，这类题目相对来说比较简单，在我看来掌握树形的最大要点就是递归的思想，这可以说用在了这类题目中的方方面面。主要涉及这些题型：
 构建树（数组，链表） 遍历，判断是合理的树 找节点（LCA） 树的基本属性（高度），找路径  构建树 这类题目的基本思路就是先找到根结点（root），然后把整个数组或者链表分成左右两个部分。之后，这个根节点的左子树就是递归调用数组的右半部分。右半边子树就是递归调用，这个函数的右半部分。总体还是比较简单的，题目可以参看
 108.Convert Sorted Array to Binary Search Tree 109.Convert Sorted List to Binary Search Tree  这里有一道题，关于如何利用链表来构造。其中有一点，它可以使用一个固定的prev linked list node。在每次递归结束的时候都会调用next，这样我们就不需要每次遍历找到中心结点，而是利用之前的结果来找到中间的那个节点。也就是说，在这里我们并不需要一开始就把父节点找到，而是可以先存好左子树，之后再到root。
private ListNode list; private TreeNode sortedListToBST(int start, int end) { if (start &amp;gt; end) return null; int mid = (start + end+1) / 2; TreeNode leftChild = sortedListToBST(start, mid-1); TreeNode parent = new TreeNode(list.val); parent.left = leftChild; list = list.</description>
    </item>
    
  </channel>
</rss>