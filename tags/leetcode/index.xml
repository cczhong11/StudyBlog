<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on Learn More</title>
    <link>http://study.tczhong.com/tags/leetcode/</link>
    <description>Recent content in Leetcode on Learn More</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 04 Sep 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://study.tczhong.com/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>DP算法题的思考</title>
      <link>http://study.tczhong.com/post/algo/dp/</link>
      <pubDate>Tue, 04 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://study.tczhong.com/post/algo/dp/</guid>
      <description>DP 算法题目的思考 dp全称是动态规划，是一类被人又喜欢又讨厌的题目。喜欢是因为找到递推关系之后题目就变得简单了，讨厌的原因是这类题目常常很难想到递推关系。
dp的核心思想就是把一个复杂的问题分解成简单的子问题，并且可以利用递推的方式来解决。所有dp题目的核心是： 1. 递推公式 deduction formula 2. 初始化 initialization 3. 空间优化 space improvement
路径数量 这类题目就是看有几种方式可以到这个点，然后把这几种方式的路径加起来就可以。这是自下而上的思想，对于青蛙跳的那道题也可以自上而下利用递归的思路解题。只要可以跳到，就可以变成一个子问题，把这个点当做起点来进行。
word break 这类题目就可以使用相同的思想。思路是判断前i个是否可以组成，之后就判断这从i到j是否是一个单词。如果要记录下来所有的组成可能的话就可以使用dfs了。
 62. Unique Paths 63. Unique Paths II 64. Minimum Path Sum 70. Climbing Stairs 91. Decode Ways 139. Word Break 198. House Robber 213. House Robber II 338. Counting Bits 357. Count Numbers with Unique Digits 403. Frog Jump 518. Coin Change 2 746. Min Cost Climbing Stairs 413.</description>
    </item>
    
    <item>
      <title>Graph算法题的思考</title>
      <link>http://study.tczhong.com/post/algo/graph/</link>
      <pubDate>Tue, 28 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://study.tczhong.com/post/algo/graph/</guid>
      <description>graph 算法题目思考 Graph算是非常常见的题目，一般会给你一个2d array或一个数组代表联系，你可以使用这个输入来转换成一个图表示的数据结构，之后在图里做搜索。常见的算法：
 BFS，DFS union find A* Floyd and dijkstra  Leetcode里的题目的话主要都是dfs, bfs就可以解决，有些需要思考几个之间的关系的题目可以使用union find来做。少部分计算路径的题目需要使用一些基本的最短路径算法。
BFS and DFS BFS就是使用一个queue,每次在遍历一个点的时候就把这个点放到queue里，是一个FIFO的结构。一层一层的遍历，基本应用是在tree level 遍历。这种方法找最短路径比较好，问题是一次要走很多。相对来说，BFS和DFS都可以解决一道题目，区别只是遍历的顺序不同。 DFS需要使用stack来解决，或者递归。
 127. Word Ladder 130. Surrounded Regions 133. Clone Graph  对于找所有东西是不是一类的题目，经典题目就是看有几个岛的题目，利用dfs可以很方便的写出来。如果是无向图的话，从区域里的任意一点应该是可以到这个区域里任意一点的。所以只要有这个就可以找到所有是一类的点。
 200. Number of Islands 286. Walls and Gates  Dfs也可以用来实现有向图找环的策略，基本思路就是把图中的点标为白色（unvisited）,灰色(visiting)，黑色(visited)。如果在访问途中遇到灰色的节点，就说明这个点被访问过了，图中有环。
Union find 这类题目一般都是存在多个点属于一个类别的题目，之后可以通过图的关系把这些点合并到一个类别里面。union find 可以用来找无向图中是否有环。基本算法如下：
class DSU { int[] parent; public DSU(int N) { parent = new int[N]; for (int i = 0; i &amp;lt; N; ++i) parent[i] = i; } public int find(int x) { if (parent[x] !</description>
    </item>
    
    <item>
      <title>Array算法题的思考</title>
      <link>http://study.tczhong.com/post/algo/array/</link>
      <pubDate>Fri, 24 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://study.tczhong.com/post/algo/array/</guid>
      <description>Array 算法题的思考 数组类的算法是在我做的题目中是最多的，相对来说也是最好理解的它也可以包罗万象，使用各种各样的算法。用数组可以实现很多基本的数据结构。比如heap。所以这部分需要好好掌握。
SWAP 需要应用到数组元素交换是一类非常常见的题目，比如说求最大的K个数，这种题目一般都是使用基本的快速排序思想。也就是说，我们把这个数组分成两部分，一部分是比当前这个数字大的，另外一部分是比这个当前数字小的，这样我们可以快速的把一个array分成两部分，然后再分别对这两部分进行处理。
如果只是需要移动一些数字，比如说移动零或者整个数组只有三个数，那么可以用一些更简单思想，比如说记录下所有非0的数，或者记录下这些数字的个数，然后把前面全换成这些非0数，后面换成零。这样做的好处就是不需要交换。或者一个记录非0的地方，另外一个记录当前位置，如果这个不是零，那么就遇上一个非0的东西交换。所以总体思路都是双指针的思想，一个记录当前遍历的位置，另外一个记录上一次符合条件的位置。
 27. Remove Element 75. Sort Colors 283. Move Zeroes 215. Kth Largest Element in an Array  subarray 这又是一大类数组常遇到的题目，比如说求子数组的和，或者判断这个子数组是否符合某些规律等等。与字符串处理substring有异曲同工之妙，一般也都是双指针，如果发现和大于某个值的时候，那么就把起始值增大。
另外一种常见的思路就是记录从零开始到现在的子序列的和。然后，用当前的和减去目标值，然后看这个值是否在我们存好的hashmap里，如果在的话就说明存在这么个序列，我们就可以返回这个值。这类题目需要先判断有没有，再加入map，避免0的问题。当限制subarray长度时也可以用两个数字代表，不使用hashtable。
对于求max average的题目，可以使用binary search找这个最大的average，思路不是很直接。就是直接找这个值，然后看存不存在符合的subarray.
其中一个有趣的地方是可以用加法代替乘法，换成log。
 53. Maximum Subarray 325. Maximum Size Subarray Sum Equals k 209. Minimum Size Subarray Sum 560. Subarray Sum Equals K 643. Maximum Average Subarray I 644. Maximum Average Subarray II 713. Subarray Product Less Than K  对于subarray个数的题目可以一般有这个思路： - 1，2 中subarray个数为[1],[2],[1,2] - 1,2,3 中subarray个数为[1],[2],[1,2],[1,3],[2,3],[1,2,3]</description>
    </item>
    
    <item>
      <title>String算法题的思考</title>
      <link>http://study.tczhong.com/post/algo/string/</link>
      <pubDate>Wed, 22 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://study.tczhong.com/post/algo/string/</guid>
      <description>String 算法思考 String 类型的题目算是leetcode里第二多的题型，其实这个和array的使用方法差不太多，只不过其中有一些特定的使用场景。我在这里会将string分为几类问题，可能不能包括所有的类别，尽量使用较为统一的思路解释遇到的题目。
数据类型 首先要说清楚一点，在java中String是immutable的，也就是当你创建一个string后是不能修改的，如果你需要给他加内容，java会重新创一个新的实例。这样的问题就是如果使用s+=a,这样时间复杂度是O(n),在java中会重新复制一遍string再给你创建。
解决办法就是使用StringBuilder，这个的时间复杂度对于增加就是O(1).其中内部实现就是一个char[]
 sb.append(String str) sb.toString()  组合问题 这类问题就是需要得到某个字符串中包含的所有子集,或者是permutation.这类题日非常相似，需要找出符合条件的所有组合。基本思路是样的，可以使用DFS与backtrack实现。例如 Combination Sum,可以把这题变成一个子问题选择了数字n后，求解sum-n的子问题的解答。所以可以先排序选择第一个元素，然后在函数中记录以下这些：
 结果列表 当前路径存入的值， 所有可能的值 剩余的Sum 当前选择的位置,深度  在执行递归前将数字存入，在执行后从数组中删去。如果是计算permutation, 在参种增加一个数组用来判断当前数字是否访过。类似的题目有以下这些：
 17. Letter Combinations of a Phone Number 282. Expression Add Operators 39. Combination Sum 40. Combination Sum II 78. Subsets 79. Word Search 46. Permutations 47. Permutations II 266. Palindrome Permutation 267. Palindrome Permutation II 494. Target Sum 679. 24 Game 491. Increasing Subsequences  一个注意点是：如果是用list的话，当加入结果的时候，每次需要重新构造一个新的： rs.</description>
    </item>
    
    <item>
      <title>树形算法题的思考</title>
      <link>http://study.tczhong.com/post/algo/tree/</link>
      <pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://study.tczhong.com/post/algo/tree/</guid>
      <description>树形算法题的思考 树形是一大题型，这类题目相对来说比较简单，在我看来掌握树形的最大要点就是递归的思想，这可以说用在了这类题目中的方方面面。主要涉及这些题型：
 构建树（数组，链表） 遍历，判断是合理的树 找节点（LCA） 树的基本属性（高度），找路径  构建树 这类题目的基本思路就是先找到根结点（root），然后把整个数组或者链表分成左右两个部分。之后，这个根节点的左子树就是递归调用数组的右半部分。右半边子树就是递归调用，这个函数的右半部分。总体还是比较简单的，题目可以参看
 108.Convert Sorted Array to Binary Search Tree 109.Convert Sorted List to Binary Search Tree  这里有一道题，关于如何利用链表来构造。其中有一点，它可以使用一个固定的prev linked list node。在每次递归结束的时候都会调用next，这样我们就不需要每次遍历找到中心结点，而是利用之前的结果来找到中间的那个节点。也就是说，在这里我们并不需要一开始就把父节点找到，而是可以先存好左子树，之后再到root。
private ListNode list; private TreeNode sortedListToBST(int start, int end) { if (start &amp;gt; end) return null; int mid = (start + end+1) / 2; TreeNode leftChild = sortedListToBST(start, mid-1); TreeNode parent = new TreeNode(list.val); parent.left = leftChild; list = list.</description>
    </item>
    
  </channel>
</rss>